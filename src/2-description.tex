% !TEX root = Ragni2016.tex

%  ___                 _      _   _
% |   \ ___ ___ __ _ _(_)_ __| |_(_)___ _ _
% | |) / -_|_-</ _| '_| | '_ \  _| / _ \ ' \
% |___/\___/__/\__|_| |_| .__/\__|_\___/_||_|
%                       |_|
\section{Software description}
\label{sec:description}

% Describe the software in as much as is necessary to establish a vocabulary needed to explain
% its impact.

%    _          _    _ _          _
%   /_\  _ _ __| |_ (_) |_ ___ __| |_ _  _ _ _ ___
%  / _ \| '_/ _| ' \| |  _/ -_) _|  _| || | '_/ -_)
% /_/ \_\_| \__|_||_|_|\__\___\__|\__|\_,_|_| \___|
\subsection{Software Architecture}
\label{sec:architecture}

% Give a short overview of the overall software architecture; provide a pictorial component overview
% or similar (if possible). If necessary provide implementation details.

\ragnicas~is an object oriented ASD gem that supports some computer algebra routines such as \emph{simplifications} and \emph{substitutions}. When gem is required, it automatically overloads methods of \Fixnum~and \Float~classes, to make them compatible with the foundamental symbolic class.

Each symbolic expression (or operation) is the instance of an object, that inherits from a common virtual ancestor: \CASOp. An operation encapsulates sub-operations recursively, building a linked graph, that is the mathematical equivalent of function composition:
\begin{equation}
\left( f \, \circ \, g \right)
\end{equation}

\begin{figure}[ht!]
\label{fig:graph}
\centering
\input{img/graph-ex}
\caption{Example graph from the first function reported in listing~\ref{code:example-diff}}
\end{figure}

When a new operation is created, it is appended to the graph. The number of branches are determined by the parent container class of the current symbolic function. There are three possible containers. Single argument operations --- e.g. $\sin(\cdot)$ --- have as closest parent the \CASOp~class, that links to one sub-graph. Expressions with two arguments --- e.g.\ difference or exponential function --- inherit from \CASBinaryOp, that links to two subgraphs. Operations with arbitrary number of arguments --- e.g.\ sum and product --- have as parent the \CASNaryOp\footnote{Please note that this container is still at experimental stage}, that links to an arbitrary number of subgraph. Figure~\ref{fig:graph} contains an example of graph. The different kind of containers allows to introduce some properties --- i.e. \emph{associativity} and \emph{commutativity} for sums and multiplications~\cite{cohen2003computer}. Each container exposes the subgraphs as instance properties. Containers interfaces and inheritances are shown in Figure~\ref{fig:uml-container}.

Terminal leafes of the graph are the classes \CASConstant, \CASVariable~and \CASFunction. The first models a simple numerical value, while the second represents an independent variable, that can be used to perform derivatives and evaluations, and the latter is a prototype of an implicit function. As for now, those leafes exemplify only real scalar expressions, with definition of complex, vectorial and matricial extensions as milestones for the next major release.

SD (\CASOpdiff) crosses the graph until it reaches the ending node. The terminal node is the starting point for derivatives accumulation, the mathematical equivalent of the chain rule:
\begin{equation}
\left( f  \, \circ \, g \right)' \: = \:
\left( f' \, \circ \, g \right) \: g'
\end{equation}
The recursiveness is used also for simplifications (\CASOpsimplify), substitutions (\CASOpsubs), evaluations (\CASOpcall) and code generation.

\begin{figure}[ht!]
\label{fig:uml-container}
\centering
\input{img/class-struct}
\caption{Simplified version of classes interface and inheritance}
\end{figure}

%  ___             _   _               _ _ _   _
% | __|  _ _ _  __| |_(_)___ _ _  __ _| (_) |_(_)___ ___
% | _| || | ' \/ _|  _| / _ \ ' \/ _` | | |  _| / -_|_-<
% |_| \_,_|_||_\__|\__|_\___/_||_\__,_|_|_|\__|_\___/__/
\subsection{Software Functionalities}
\label{sec:functionalities}

\subsubsection{Software installation and prerequisites}

Core functionalities has no dependencies. The gem can be installed through \emph{rbygems.org} provider: \texttt{gem install ragni-cas}. Functionalities must be required runtime using the Kernel method: \texttt{require 'ragni-cas'}. All methods and classes are incapsulated in the module \texttt{CAS}.

\subsubsection{Basic Functionalities}
% Present the major functionalities of the software.
\textbf{SD} can be performed with respect to an independent variable (\CASVariable) through forward accumulation, even for implicit functions. The differentiation is done by a method of the \CASOp, having a \CASVariable~as argument:

\noindent%
\begin{lstlisting}[caption={Differentiation example},label={code:example-diff}]
z = CAS.vars 'z'           # creates a variable
f = z ** 2 + 1             # define a symbolic expression
f.diff(z)                  # derivative w.r.t. z
# => 2 * z ^ (2 - 1) + 0
g = CAS.declare :g, f      # creates implicit expression
g.diff(z)                  # derivative w.r.t. z
# => (z ^ (2 - 1) * 2) * Dg[0](z ^ 2)
\end{lstlisting}

\textbf{Automatic differentiation} (AD) is implemented using dual numbers \cite{bartholomew2000automatic}, and it is included as a plugin. This differentiation strategy can be used in case oectremely complex expressions, whose explicit derivative graph may exceed the call stack depth, that is platform dependent.

\textbf{Simplifications} are not executed automatically, after differentiations. Each node of the graph knows rules for simplify itself, and rules are called recursively inside the graph, exactly like ASD.\@ Simplifications that require an \emph{heuristic expansion} of the subgraph --- i.e.\ some trigonometric identities --- are not defined for now, but they can be easily achieved through \textbf{substitutions}:

\noindent%
\begin{lstlisting}[caption={Simplification example},label={code:example-simp}]
x, y = CAS::vars 'x', 'y'        # creates two variables
f = CAS.log( CAS.sin( y ) )      # symbolic expression
f.subs  y: CAS.asin(CAS.exp(x))  # perform substitution
f.simplify                       # simplify expression
# => x
\end{lstlisting}

The graph is numerically \textbf{evaluated} when independent variables values are provided in a feed dictionary. The graph is reduced recursively to a single numeric value:

\noindent%
\begin{lstlisting}[caption={Graph evaluation example},label={code:example-call}]
x = CAS.vars 'x'          # creates a variable
f = x ** 2 + 1             # define a symbolic expression
f.call x => 2              # evaluate for x = 2
# => 5
\end{lstlisting}

Symbolic expressions can be used to create comparative expressions --- e.g. $f(\cdot) \geq g(\cdot)$ --- or piecewise functions --- e.g. $\max(f(\cdot), g(\cdot))$:

\noindent%
\begin{lstlisting}[caption={Expressions and Piecewise functions},label={code:example-expr}]
x, y = CAS.vars 'x', 'y'
f = CAS.declare :f, x
g = CAS.declare :g, x, y
f.greater_equal g
# => (f(x) >= g(x, y))
CAS::max f, g
# => ((f(x) >= g(x, y)) ? f(x) : g(x, y))
\end{lstlisting}
Comparative expression are stored in a special container classes, modeled by the ancestor \CASExpression.

\subsubsection{Metaprogramming and Code-Generation}

The library is developed explicitly for \textbf{generation of code} for a target language, and \textbf{meta\-programming}. Expressions, once manipulated, can be exported as plain source code or used as a prototype for a callable \emph{closure} (\texttt{Proc} object):

\noindent%
\begin{lstlisting}[caption={Graph evaluation example},label={code:example-proc}]
x = CAS::vars 'x'             # creates a variable
f = CAS::log(CAS::sin(x))     # define a symbolic function

proc = f.as_proc              # exports callable lambda
proc.call 'x' => Math::PI/2
# => 0.0
\end{lstlisting}
Composing a closure of a graph is like making its snapshot, thus any further manipulation to the expression do not update the callable object. This drawback is balanced by the faster execution time of a \texttt{Proc}: when a graph needs only to be evaluated in a iterative algorithm, and not to be manipulated, transforming it in a \emph{closure} reduces the execution time per iteration.

Code generation should be flexible enough to export a graph in a user's target language. Generation methods for common languages are included in specific plugins. Users can furthemore expand exporting capabilites by writing specific exportation rules,  overriding method for existing plugin, or desining their own exporter:

\noindent%
\begin{lstlisting}[caption={Example of Ruby exportation plugin},label={code:example-exporting}]
# Definition
module CAS
  {
    # . . .
    CAS::Variable => Proc.new { "#{name}" }
    CAS::Sin      => Proc.new { "Math.sin(#{x.to_ruby})" },
    # . . .
  }.each do |cls, prc|
    cls.send(:define_method, :to_ruby, &prc)
  end
end

# Usage
x = CAS.vars 'x'
(CAS.sin(x)).to_ruby
# => Math.sin(x)
\end{lstlisting}
