% !TEX root = Ragni2016.tex

%  ___                     _
% | __|_ ____ _ _ __  _ __| |___ ___
% | _|\ \ / _` | '  \| '_ \ / -_|_-<
% |___/_\_\__,_|_|_|_| .__/_\___/__/
%                    |_|
\section{Illustrative Examples}
\label{sec:examples}

\subsection{Code Generation as C Library}
This example shows how to export a C library using the \texttt{CAS} module as design interface. \texttt{c-opt} plugin implements advanced features such as code optimization and generation of libraries.

In this example we create a library \texttt{example} that implements the model:
\begin{equation}
f(x, y) = x^y + g(x)\, \log(\sin(x^y))
\end{equation}
Expression $g(x)$ is implemented as \texttt{g\_impl} and its interface is described in the external header \texttt{g\_impl.h}. The code must be optimized: the intermediate operation $x^y$ should be evaluated once, even if required twice in our model. The C function that implements our model $f(x,y)$ should be called with the token \texttt{f\_impl}. The exporter uses as default type, for variables and function returned values, \texttt{double}.

\begin{lstlisting}[caption={Calling optimized-C exporter for library generation},label={code:example-exporting-C-1}]
require 'ragni-cas/c-opt'

# Model
x, y = CAS.vars :x, :y
g = CAS.declare :g, x

f = x ** y + g * CAS.log(CAS.sin(x ** y))

# Code Generation
g.c_name = 'g_impl'             # g token

CAS::CLib.create "example" do
  include_local "g_impl"        # g header
  implements_as "f_impl", f     # token for f
end
\end{lstlisting}
Library created by class \texttt{CLib} contains the following code:

\noindent%
  \begin{minipage}{.5\textwidth}
    \lstinputlisting[style=customruby,language=C,caption={C Header}]{./scripts/source.h}
  \end{minipage}\hfill
  \begin{minipage}{.5\textwidth}
    \lstinputlisting[style=customruby,language=C,caption={C Source},frame=tbl]{./scripts/source.c}
  \end{minipage}

The function $g(x)$ contains the following operation:
\begin{equation}
g(x) = (\sqrt{x + a} - \sqrt{a}) + \sqrt{\pi + x}
\end{equation}
that is a function that may suffer from catastrophic cancellation~\cite{higham2002accuracy}. If a user wants to specialize code generation
rules for this particular expression, conditioned through rationalization\footnote{i.e.: $\sqrt{x + a} - \sqrt{a} = \dfrac{a}{\sqrt{x + a} + \sqrt{a}}$}. We want also to extend this strategy to all differences of square roots. For more insight about \texttt{\_\_to\_c} and \texttt{\_\_to\_c\_impl} please refer to the software manual.

\noindent%
\begin{lstlisting}[caption={Conditioning in exporting function},label={code:example-exporting-C-2}]
# Model
a = CAS.declare "PARAM_A"

g = (CAS.sqrt(x + a) - CAS.sqrt(x)) + CAS.sqrt(CAS::Pi + x)

# Particular Code Generation for difference between square roots.
module CAS
  class Diff
    alias :__to_c_impl_old :__to_c_impl

    def __to_c_impl(v)
      if @x.is_a? CAS::Sqrt and @y.is_a? CAS::Sqrt
        "(#{@x.x.__to_c(v)} + #{@y.x.__to_c(v)}) / " +
        "( #{@x.__to_c(v)} + #{@y.__to_c(v)} )"
      else
        self.__to_c_impl_old(v)
      end
    end
  end
end

clib = CAS::CLib.create "g_impl" do
  define "PARAM_A()", 1.0   # Arbitrary value for PARAM_A
  define "M_PI", Math::Pi
  implements_as "g_impl", g
end
\end{lstlisting}
It should be noted the \textbf{separation between the model} --- that does not contain conditioning --- \textbf{and the code generation rule} --- that overloads for this particular case and this particular language the normal exportation rule. The result of listing~\ref{code:example-exporting-C-2} is reported:

\noindent%
  \begin{minipage}{.5\textwidth}
    \lstinputlisting[style=customruby,language=C,caption={\texttt{g\_impl} Header}]{./scripts/g_impl.h}
  \end{minipage}\hfill
  \begin{minipage}{.5\textwidth}
    \lstinputlisting[style=customruby,language=C,caption={\texttt{g\_impl} Source},frame=tbl]{./scripts/g_impl.c}
  \end{minipage}

\subsection{Using the module as interface}
As example, an implementation of an algorithm that extimates the \emph{order of convergence} for trapezoidal integration scheme \cite{weideman2002numerical} is provided, using the symbolic differentiation as interface.

Given a function $f(x)$, the trapezoidal rule for primitive estimation in the interval $[a,\,b]$ is:
\begin{equation}
  I_{n}(a, b) = \dfrac{b - a}{n} \left( \dfrac{f(a) + f(b)}{2} +
    \sum\limits_{k = 1}^{n - 1}{f \left( a + k \dfrac{b - a}{n} \right)} \right)
\end{equation}
where $n$ mediates the integration's step size. When exact primitive $F(x)$ is known, approximation error is:
\begin{equation}
  E[n] = F(b) - F(a) - I_{n}(a, b)
\end{equation}
This error shows a direct relation:
\begin{equation}
  E[n] \propto C\,{n}^{-p}
\end{equation}
where $p$ is the convergence order. Using a different value for $n$, for example $2\,n$:
\begin{equation}
  \dfrac{E[n]}{E[2\,n]} \approx 2^{p} \quad \rightarrow \quad p \approx log_2 \left( \dfrac{E[n]}{E[2\,n]} \right)
\end{equation}
Following listings contain the implementation of the described procedure using the described gem and the well known \emph{Python} \cite{van2011python} library \emph{sympy} \cite{christopher_smith_2016_47274}.

\noindent%
  \begin{minipage}{.5\textwidth}
    \lstinputlisting[style=customruby,caption={Ruby version}]{./scripts/test.rb}
  \end{minipage}\hfill
  \begin{minipage}{.5\textwidth}
    \lstinputlisting[style=customruby,language=python,caption={Python version},frame=tbl]{./scripts/test.py}
  \end{minipage}
